// ==UserScript==
// @name         Shogi-Instructor bridge (lishogi)
// @namespace    shogi-instructor
// @version      0.1.0
// @description  Intercept lishogi round data and beacon to localhost
// @match        https://lishogi.org/*
// @run-at       document-end
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  const ENDPOINT = "http://127.0.0.1:3080/api/chunk";
  const INTERVAL_MS = 200;
  const CHUNK_SIZE = 1200;
  const MAX_INFLIGHT = 8;

  const te = new TextEncoder();

  function b64urlFromBytes(bytes) {
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function b64urlFromString(str) {
    return b64urlFromBytes(te.encode(str));
  }
  function fnv1a32(str) {
    let h = 0x811c9dc5;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = (h + (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24)) >>> 0;
    }
    return ("00000000" + h.toString(16)).slice(-8);
  }

  function sendImg(url) {
    return new Promise((resolve) => {
      const img = new Image();
      img.referrerPolicy = "no-referrer";
      img.onload = img.onerror = () => resolve();
      img.src = url;
    });
  }

  async function sendWithLimit(urls, limit) {
    let i = 0;
    const workers = Array.from({ length: Math.min(limit, urls.length) }, async () => {
      while (i < urls.length) await sendImg(urls[i++]);
    });
    await Promise.all(workers);
  }

  let lastHash = null;

  async function chunkAndSend(obj) {
    const json = JSON.stringify(obj);
    const hash = fnv1a32(json);
    if (hash === lastHash) return;
    lastHash = hash;

    const b64 = b64urlFromString(json);
    const id = `${hash}-${Date.now().toString(36)}`;
    const total = Math.ceil(b64.length / CHUNK_SIZE);
    const urls = [];

    for (let idx = 0; idx < total; idx++) {
      const part = b64.slice(idx * CHUNK_SIZE, (idx + 1) * CHUNK_SIZE);
      urls.push(
        `${ENDPOINT}?id=${encodeURIComponent(id)}` +
        `&h=${encodeURIComponent(hash)}&i=${idx}&n=${total}&d=${part}&t=${Date.now()}`
      );
    }
    await sendWithLimit(urls, MAX_INFLIGHT);
  }

  function pickRoundData(d) {
    const steps = d?.steps;
    if (!steps) return null;

    const playerColor = d?.player?.color;
    const opponentColor = d?.opponent?.color;

    const isColor = (c) => c === "sente" || c === "gote";
    const opposite = (c) => (c === "sente" ? "gote" : "sente");

    const payload = { steps };

    if (isColor(playerColor)) payload.player = { color: playerColor };

    if (isColor(playerColor) && isColor(opponentColor)) {
      const expected = opposite(playerColor);
      console.assert(
        opponentColor === expected,
        `Unexpected opponent.color: expected "${expected}", got "${opponentColor}"`
      );
      payload.opponent = { color: opponentColor };
    }

    return payload;
  }

  // Wait for lishogi to initialize before hooking.
  function waitForLishogiReady(cb) {
    const t = setInterval(() => {
      const w = window;
      if (w?.lishogi?.xhr?.json && w?.lishogi?.modulesData?.round?.data) {
        clearInterval(t);
        cb();
      }
    }, 50);
  }

  waitForLishogiReady(() => {
    let latestData = window.lishogi.modulesData.round.data;

    const origXhrJson = window.lishogi.xhr.json.bind(window.lishogi.xhr);
    window.lishogi.xhr.json = function (method, url, ...args) {
      return origXhrJson(method, url, ...args).then((data) => {
        if (data && data.steps) {
          window.dispatchEvent(new CustomEvent("lishogi-game-data", { detail: data }));
        }
        return data;
      });
    };

    window.addEventListener("lishogi-game-data", (e) => {
      latestData = e.detail;
    });

    setInterval(() => {
      const payload = latestData ? pickRoundData(latestData) : null;
      if (payload) chunkAndSend(payload).catch(() => {});
    }, INTERVAL_MS);

    console.log("[Shogi-Instructor bridge] installed");
  });
})();